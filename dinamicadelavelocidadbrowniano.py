# -*- coding: utf-8 -*-
"""DinamicadelaVelocidadBrowniano.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J1jddM6TKpU1lhroO3wBcAMK23GDu-Vp
"""

import numpy as np
import matplotlib.pyplot as plt

# Parámetros físicos

#masa
m = 1.0
#coeficiente de friccion
beta = 1.0
#carga-
q = 1.0
#Campo magnético que esta en z
B = 2.0
#constante de Boltzman
kB = 1.0
#Temperatura
T = 1.0

#Parámetros de la derivada
gamma = beta / m
omega_c = q* B / m
sigma = np.sqrt(2 * beta * kB * T / m**2)


#Parámetros num+ericos


dt = 0.001
t_max = 20.0
N = int(t_max / dt )

Vx = np.zeros(N)
Vy = np.zeros(N)
Vz = np.zeros(N)



#COndiciones iniciales

Vx[0] = 1.0
Vy[0] = 0.0
Vz[0] = 0.5

time = np.linspace(0, t_max, N)

#Simulación (Euler-Maruyami)

for n in range(N-1):
  eta_x = np.random.normal(0, 1)
  eta_y = np.random.normal(0, 1)
  eta_z = np.random.normal(0, 1)

  Vx[n+1] = (
      Vx[n]
      + (-gamma * Vy[n] + omega_c * Vy[n])* dt
      + sigma * eta_x * np.sqrt(dt)
  )


  Vy[n+1] = (
      Vy[n]
      + (-gamma * Vy[n] - omega_c * Vx[n])* dt
      + sigma * eta_y * np.sqrt(dt)
  )

  Vz[n+1] = (
      Vz[n]
      -gamma * Vz[n] * dt
      +sigma * eta_z * np.sqrt(dt)
  )

#Verificacón del equilibrio

print("Varianza numéricas:")
print("<Vx^2> =", np.mean(Vx[int(N/2):]**2))
print("<Vz^2> =", np.mean(Vy[int(N/2):]**2))
print("<Vy^2> =", np.mean(Vz[int(N/2):]**2))

print("Varianza teórica:= ", kB*T/m)

#Gráfica

plt.figure()
plt.plot(time, Vx,)
plt.xlabel("Tiempo")
plt.ylabel("Velocidad en x")
plt.title("Evolución de la velocidad en x")
plt.show()

plt.figure()
plt.plot(time, Vy)
plt.xlabel("Tiempo")
plt.ylabel("Velocidad en y")
plt.title("Evolución de la velocidad en y")
plt.show()

plt.figure()
plt.plot(time, Vz)
plt.xlabel("Tiempo")
plt.ylabel("Velocidad en z")
plt.title("Evolución de la velocidad en z")
plt.show()